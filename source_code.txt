Project Path: kuznechik

Source Tree:

```txt
kuznechik
├── __tests__
│   ├── alg.test.ts
│   ├── keystore.test.ts
│   └── transforms.test.ts
├── index.ts
└── src
    ├── algcbc.ts
    ├── algcfb.ts
    ├── algctr.ts
    ├── algecb.ts
    ├── algmac.ts
    ├── algofb.ts
    ├── keystore.ts
    ├── tables.ts
    ├── transforms.ts
    └── types.ts

```

`kuznechik/__tests__/alg.test.ts`:

```ts
import { describe, test, expect } from "vitest";
import { KeyStore, AlgEcb, AlgCtr, AlgOfb, AlgCbc, AlgCfb, AlgMac } from "../";

const DATA = new Uint8Array([
  0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0xff, 0xee, 0xdd, 0xcc, 0xbb,
  0xaa, 0x99, 0x88, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99,
  0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77,
  0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00, 0x22, 0x33, 0x44, 0x55,
  0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xee, 0xff, 0x0a, 0x00, 0x11,
]);

describe("AlgEcb", () => {
  test("encrypt_decrypt", () => {
    const masterKey = new Uint8Array([
      0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33,
      0x44, 0x55, 0x66, 0x77, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
      0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    ]);

    const kuz = new KeyStore();
    kuz.setMasterKey(masterKey);

    const alg = new AlgEcb(kuz);

    const expectedEncData = new Uint8Array([
      0x7f, 0x67, 0x9d, 0x90, 0xbe, 0xbc, 0x24, 0x30, 0x5a, 0x46, 0x8d, 0x42,
      0xb9, 0xd4, 0xed, 0xcd, 0xb4, 0x29, 0x91, 0x2c, 0x6e, 0x00, 0x32, 0xf9,
      0x28, 0x54, 0x52, 0xd7, 0x67, 0x18, 0xd0, 0x8b, 0xf0, 0xca, 0x33, 0x54,
      0x9d, 0x24, 0x7c, 0xee, 0xf3, 0xf5, 0xa5, 0x31, 0x3b, 0xd4, 0xb1, 0x57,
      0xd0, 0xb0, 0x9c, 0xcd, 0xe8, 0x30, 0xb9, 0xeb, 0x3a, 0x02, 0xc4, 0xc5,
      0xaa, 0x8a, 0xda, 0x98,
    ]);

    const encData = alg.encrypt(DATA);
    const decData = alg.decrypt(encData);

    expect(encData.subarray(0, 64)).toEqual(expectedEncData);
    expect(decData).toEqual(DATA);
  });
});

describe("AlgCtr", () => {
  test("encrypt_decrypt", () => {
    const gamma = new Uint8Array([
      0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xce, 0xf0, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
    ]);

    const masterKey = new Uint8Array([
      0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33,
      0x44, 0x55, 0x66, 0x77, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
      0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    ]);

    const expectedEncData = new Uint8Array([
      0xf1, 0x95, 0xd8, 0xbe, 0xc1, 0x0e, 0xd1, 0xdb, 0xd5, 0x7b, 0x5f, 0xa2,
      0x40, 0xbd, 0xa1, 0xb8, 0x85, 0xee, 0xe7, 0x33, 0xf6, 0xa1, 0x3e, 0x5d,
      0xf3, 0x3c, 0xe4, 0xb3, 0x3c, 0x45, 0xde, 0xe4, 0xa5, 0xea, 0xe8, 0x8b,
      0xe6, 0x35, 0x6e, 0xd3, 0xd5, 0xe8, 0x77, 0xf1, 0x35, 0x64, 0xa3, 0xa5,
      0xcb, 0x91, 0xfa, 0xb1, 0xf2, 0x0c, 0xba, 0xb6, 0xd1, 0xc6, 0xd1, 0x58,
      0x20, 0xbd, 0xba, 0x73,
    ]);

    const kuz = new KeyStore();
    kuz.setMasterKey(masterKey);
    const alg = new AlgCtr(kuz);
    alg.setGamma(gamma.slice());

    const encData = alg.encrypt(DATA);
    alg.setGamma(gamma.slice());
    const decData = alg.decrypt(encData);

    expect(encData).toEqual(expectedEncData);
    expect(decData).toEqual(DATA);
  });
});

describe("AlgOfb", () => {
  test("encrypt_decrypt", () => {
    const gamma = new Uint8Array([
      0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xce, 0xf0, 0xa1, 0xb2, 0xc3, 0xd4,
      0xe5, 0xf0, 0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x90,
      0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
    ]);

    const masterKey = new Uint8Array([
      0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33,
      0x44, 0x55, 0x66, 0x77, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
      0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    ]);

    const expectedEncData = new Uint8Array([
      0x81, 0x80, 0x0a, 0x59, 0xb1, 0x84, 0x2b, 0x24, 0xff, 0x1f, 0x79, 0x5e,
      0x89, 0x7a, 0xbd, 0x95, 0xed, 0x5b, 0x47, 0xa7, 0x04, 0x8c, 0xfa, 0xb4,
      0x8f, 0xb5, 0x21, 0x36, 0x9d, 0x93, 0x26, 0xbf, 0x66, 0xa2, 0x57, 0xac,
      0x3c, 0xa0, 0xb8, 0xb1, 0xc8, 0x0f, 0xe7, 0xfc, 0x10, 0x28, 0x8a, 0x13,
      0x20, 0x3e, 0xbb, 0xc0, 0x66, 0x13, 0x86, 0x60, 0xa0, 0x29, 0x22, 0x43,
      0xf6, 0x90, 0x31, 0x50,
    ]);

    const kuz = new KeyStore();
    kuz.setMasterKey(masterKey);
    const alg = new AlgOfb(kuz);
    alg.setGamma(gamma.slice());

    const encData = alg.encrypt(DATA);
    alg.setGamma(gamma.slice());
    const decData = alg.decrypt(encData);

    expect(encData).toEqual(expectedEncData);
    expect(decData).toEqual(DATA);
  });
});

describe("AlgCbc", () => {
  test("encrypt_decrypt", () => {
    const gamma = new Uint8Array([
      0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xce, 0xf0, 0xa1, 0xb2, 0xc3, 0xd4,
      0xe5, 0xf0, 0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x90,
      0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
    ]);

    const masterKey = new Uint8Array([
      0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33,
      0x44, 0x55, 0x66, 0x77, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
      0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    ]);

    const expectedEncData = new Uint8Array([
      0x68, 0x99, 0x72, 0xd4, 0xa0, 0x85, 0xfa, 0x4d, 0x90, 0xe5, 0x2e, 0x3d,
      0x6d, 0x7d, 0xcc, 0x27, 0x28, 0x26, 0xe6, 0x61, 0xb4, 0x78, 0xec, 0xa6,
      0xaf, 0x1e, 0x8e, 0x44, 0x8d, 0x5e, 0xa5, 0xac, 0xfe, 0x7b, 0xab, 0xf1,
      0xe9, 0x19, 0x99, 0xe8, 0x56, 0x40, 0xe8, 0xb0, 0xf4, 0x9d, 0x90, 0xd0,
      0x16, 0x76, 0x88, 0x06, 0x5a, 0x89, 0x5c, 0x63, 0x1a, 0x2d, 0x9a, 0x15,
      0x60, 0xb6, 0x39, 0x70,
    ]);

    const kuz = new KeyStore();
    kuz.setMasterKey(masterKey);
    const alg = new AlgCbc(kuz);
    alg.setIv(gamma.slice()); 

    const encData = alg.encrypt(DATA);
    alg.setIv(gamma.slice()); 
    const decData = alg.decrypt(encData);

    expect(encData.subarray(0, 64)).toEqual(expectedEncData);
    expect(decData).toEqual(DATA);
  });
});

describe("AlgCfb", () => {
  test("encrypt_decrypt", () => {
    const gamma = new Uint8Array([
      0x12, 0x34, 0x56, 0x78, 0x90, 0xab, 0xce, 0xf0, 0xa1, 0xb2, 0xc3, 0xd4,
      0xe5, 0xf0, 0x01, 0x12, 0x23, 0x34, 0x45, 0x56, 0x67, 0x78, 0x89, 0x90,
      0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19,
    ]);

    const masterKey = new Uint8Array([
      0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33,
      0x44, 0x55, 0x66, 0x77, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
      0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    ]);

    const expectedEncData = new Uint8Array([
      0x81, 0x80, 0x0a, 0x59, 0xb1, 0x84, 0x2b, 0x24, 0xff, 0x1f, 0x79, 0x5e,
      0x89, 0x7a, 0xbd, 0x95, 0xed, 0x5b, 0x47, 0xa7, 0x04, 0x8c, 0xfa, 0xb4,
      0x8f, 0xb5, 0x21, 0x36, 0x9d, 0x93, 0x26, 0xbf, 0x79, 0xf2, 0xa8, 0xeb,
      0x5c, 0xc6, 0x8d, 0x38, 0x84, 0x2d, 0x26, 0x4e, 0x97, 0xa2, 0x38, 0xb5,
      0x4f, 0xfe, 0xbe, 0xcd, 0x4e, 0x92, 0x2d, 0xe6, 0xc7, 0x5b, 0xd9, 0xdd,
      0x44, 0xfb, 0xf4, 0xd1,
    ]);

    const kuz = new KeyStore();
    kuz.setMasterKey(masterKey);
    const alg = new AlgCfb(kuz);
    alg.setIv(gamma.slice()); // Добавляем установку IV

    const encData = alg.encrypt(DATA);
    alg.setIv(gamma.slice()); // Сбрасываем IV перед дешифрованием
    const decData = alg.decrypt(encData);

    expect(encData.subarray(0, 64)).toEqual(expectedEncData);
    expect(decData).toEqual(DATA);
  });
});

describe("AlgMac", () => {
  test("encrypt", () => {
    const masterKey = new Uint8Array([
      0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33,
      0x44, 0x55, 0x66, 0x77, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
      0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    ]);

    const expectedEncData = new Uint8Array([
      0x33, 0x6f, 0x4d, 0x29, 0x60, 0x59, 0xfb, 0xe3,
    ]);

    const kuz = new KeyStore();
    kuz.setMasterKey(masterKey);
    const alg = new AlgMac(kuz);

    const encData = alg.encrypt(DATA);

    expect(encData).toEqual(expectedEncData);
  });
});

```

`kuznechik/__tests__/keystore.test.ts`:

```ts
import type { Block256 } from "../";
import { describe, test, expect } from "vitest";
import { KeyStore } from "../";

describe("KeyStore", () => {
  test("expand_key", () => {
    const masterKey: Block256 = new Uint8Array([
      0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33,
      0x44, 0x55, 0x66, 0x77, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
      0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    ]);

    const kuz = new KeyStore();
    kuz.setMasterKey(masterKey);

    const expectedKeys = [
      new Uint8Array([
        0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33,
        0x44, 0x55, 0x66, 0x77,
      ]),
      new Uint8Array([
        0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10, 0x01, 0x23, 0x45, 0x67,
        0x89, 0xab, 0xcd, 0xef,
      ]),
      new Uint8Array([
        0xdb, 0x31, 0x48, 0x53, 0x15, 0x69, 0x43, 0x43, 0x22, 0x8d, 0x6a, 0xef,
        0x8c, 0xc7, 0x8c, 0x44,
      ]),
      new Uint8Array([
        0x3d, 0x45, 0x53, 0xd8, 0xe9, 0xcf, 0xec, 0x68, 0x15, 0xeb, 0xad, 0xc4,
        0x0a, 0x9f, 0xfd, 0x04,
      ]),
      new Uint8Array([
        0x57, 0x64, 0x64, 0x68, 0xc4, 0x4a, 0x5e, 0x28, 0xd3, 0xe5, 0x92, 0x46,
        0xf4, 0x29, 0xf1, 0xac,
      ]),
      new Uint8Array([
        0xbd, 0x07, 0x94, 0x35, 0x16, 0x5c, 0x64, 0x32, 0xb5, 0x32, 0xe8, 0x28,
        0x34, 0xda, 0x58, 0x1b,
      ]),
      new Uint8Array([
        0x51, 0xe6, 0x40, 0x75, 0x7e, 0x87, 0x45, 0xde, 0x70, 0x57, 0x27, 0x26,
        0x5a, 0x00, 0x98, 0xb1,
      ]),
      new Uint8Array([
        0x5a, 0x79, 0x25, 0x01, 0x7b, 0x9f, 0xdd, 0x3e, 0xd7, 0x2a, 0x91, 0xa2,
        0x22, 0x86, 0xf9, 0x84,
      ]),
      new Uint8Array([
        0xbb, 0x44, 0xe2, 0x53, 0x78, 0xc7, 0x31, 0x23, 0xa5, 0xf3, 0x2f, 0x73,
        0xcd, 0xb6, 0xe5, 0x17,
      ]),
      new Uint8Array([
        0x72, 0xe9, 0xdd, 0x74, 0x16, 0xbc, 0xf4, 0x5b, 0x75, 0x5d, 0xba, 0xa8,
        0x8e, 0x4a, 0x40, 0x43,
      ]),
    ];

    for (let i = 0; i < 10; i++) {
      expect(kuz.keys[i]).toEqual(expectedKeys[i]);
    }
  });
});

```

`kuznechik/__tests__/transforms.test.ts`:

```ts
import { describe, test, expect } from "vitest";
import { encryptBlock, decryptBlock, tfmS, tfmR, tfmL } from "../";
import { KeyStore } from "../";
import type { Block128, Block256 } from "../";

describe("Transforms", () => {
  test("encrypt_decrypt_block", () => {
    const masterKey: Block256 = new Uint8Array([
      0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff, 0x00, 0x11, 0x22, 0x33,
      0x44, 0x55, 0x66, 0x77, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10,
      0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef,
    ]);

    const kuz = new KeyStore();
    kuz.setMasterKey(masterKey);

    const data: Block128 = new Uint8Array([
      0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x00, 0xff, 0xee, 0xdd, 0xcc,
      0xbb, 0xaa, 0x99, 0x88,
    ]);
    const dataBackup = data.slice();

    encryptBlock(data, kuz.keys);
    expect(data).toEqual(
      new Uint8Array([
        0x7f, 0x67, 0x9d, 0x90, 0xbe, 0xbc, 0x24, 0x30, 0x5a, 0x46, 0x8d, 0x42,
        0xb9, 0xd4, 0xed, 0xcd,
      ]),
    );

    decryptBlock(data, kuz.keys);
    expect(data).toEqual(dataBackup);
  });

  test("transform_s", () => {
    const data: Block128 = new Uint8Array([
      0xff, 0xee, 0xdd, 0xcc, 0xbb, 0xaa, 0x99, 0x88, 0x11, 0x22, 0x33, 0x44,
      0x55, 0x66, 0x77, 0x00,
    ]);

    tfmS(data);
    expect(data).toEqual(
      new Uint8Array([
        0xb6, 0x6c, 0xd8, 0x88, 0x7d, 0x38, 0xe8, 0xd7, 0x77, 0x65, 0xae, 0xea,
        0x0c, 0x9a, 0x7e, 0xfc,
      ]),
    );

    tfmS(data);
    expect(data).toEqual(
      new Uint8Array([
        0x55, 0x9d, 0x8d, 0xd7, 0xbd, 0x06, 0xcb, 0xfe, 0x7e, 0x7b, 0x26, 0x25,
        0x23, 0x28, 0x0d, 0x39,
      ]),
    );

    tfmS(data);
    expect(data).toEqual(
      new Uint8Array([
        0x0c, 0x33, 0x22, 0xfe, 0xd5, 0x31, 0xe4, 0x63, 0x0d, 0x80, 0xef, 0x5c,
        0x5a, 0x81, 0xc5, 0x0b,
      ]),
    );

    tfmS(data);
    expect(data).toEqual(
      new Uint8Array([
        0x23, 0xae, 0x65, 0x63, 0x3f, 0x84, 0x2d, 0x29, 0xc5, 0xdf, 0x52, 0x9c,
        0x13, 0xf5, 0xac, 0xda,
      ]),
    );
  });

  test("transform_r", () => {
    const data: Block128 = new Uint8Array([
      0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x01, 0x00,
    ]);

    tfmR(data);
    expect(data).toEqual(
      new Uint8Array([
        0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x01,
      ]),
    );

    tfmR(data);
    expect(data).toEqual(
      new Uint8Array([
        0xa5, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
      ]),
    );

    tfmR(data);
    expect(data).toEqual(
      new Uint8Array([
        0x64, 0xa5, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
      ]),
    );

    tfmR(data);
    expect(data).toEqual(
      new Uint8Array([
        0x0d, 0x64, 0xa5, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00,
      ]),
    );
  });

  test("transform_l", () => {
    const data: Block128 = new Uint8Array([
      0x64, 0xa5, 0x94, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
      0x00, 0x00, 0x00, 0x00,
    ]);

    tfmL(data);
    expect(data).toEqual(
      new Uint8Array([
        0xd4, 0x56, 0x58, 0x4d, 0xd0, 0xe3, 0xe8, 0x4c, 0xc3, 0x16, 0x6e, 0x4b,
        0x7f, 0xa2, 0x89, 0x0d,
      ]),
    );

    tfmL(data);
    expect(data).toEqual(
      new Uint8Array([
        0x79, 0xd2, 0x62, 0x21, 0xb8, 0x7b, 0x58, 0x4c, 0xd4, 0x2f, 0xbc, 0x4f,
        0xfe, 0xa5, 0xde, 0x9a,
      ]),
    );

    tfmL(data);
    expect(data).toEqual(
      new Uint8Array([
        0x0e, 0x93, 0x69, 0x1a, 0x0c, 0xfc, 0x60, 0x40, 0x8b, 0x7b, 0x68, 0xf6,
        0x6b, 0x51, 0x3c, 0x13,
      ]),
    );

    tfmL(data);
    expect(data).toEqual(
      new Uint8Array([
        0xe6, 0xa8, 0x09, 0x4f, 0xee, 0x0a, 0xa2, 0x04, 0xfd, 0x97, 0xbc, 0xb0,
        0xb4, 0x4b, 0x85, 0x80,
      ]),
    );
  });
});

```

`kuznechik/index.ts`:

```ts
export * from './src/tables';
export * from './src/transforms';
export * from './src/types';
export * from './src/keystore';
export * from './src/algmac';
export * from './src/algcbc';
export * from './src/algcfb';
export * from './src/algctr';
export * from './src/algecb';
export * from './src/algofb';

```

`kuznechik/src/algcbc.ts`:

```ts
import type { Block128 } from "./types";
import { KeyStore } from "./keystore";
import {
  encryptBlock,
  decryptBlock,
  sumMod2,
  additionBlock128_2,
  additionRevBlock2,
} from "./transforms";

const BLOCK_SIZE = 16;

export class AlgCbc {
  private keyStore: KeyStore;
  private iv: Uint8Array;

  constructor(keyStore: KeyStore) {
    this.keyStore = keyStore;
    this.iv = new Uint8Array(0);
  }

  public setIv(iv: Uint8Array): void {
    if (iv.length < BLOCK_SIZE) {
      throw new Error(
        `Initialization vector length must be at least ${BLOCK_SIZE} bytes`,
      );
    }
    this.iv = iv.slice();
  }

  public encrypt(data: Uint8Array): Uint8Array {
    this.validateIv();
    const paddedData = additionBlock128_2(data);
    const blockCount = paddedData.length / BLOCK_SIZE;

    for (let i = 0; i < blockCount; i++) {
      const block = paddedData.subarray(i * BLOCK_SIZE, (i + 1) * BLOCK_SIZE);
      sumMod2(block, this.iv.subarray(0, BLOCK_SIZE));
      encryptBlock(block, this.keyStore.keys);
      this.updateIv(block);
    }

    return paddedData;
  }

  public decrypt(data: Uint8Array): Uint8Array {
    this.validateIv();
    const blockCount = data.length / BLOCK_SIZE;
    const decryptedData = data.slice();

    for (let i = 0; i < blockCount; i++) {
      const block = decryptedData.subarray(
        i * BLOCK_SIZE,
        (i + 1) * BLOCK_SIZE,
      );
      const encryptedBlock = block.slice();
      decryptBlock(block, this.keyStore.keys);
      sumMod2(block, this.iv.subarray(0, BLOCK_SIZE));
      this.updateIv(encryptedBlock);
    }

    return additionRevBlock2(decryptedData);
  }

  private updateIv(block: Block128): void {
    const ivLength = this.iv.length;
    if (ivLength < BLOCK_SIZE) {
      throw new Error(
        `Initialization vector length must be at least ${BLOCK_SIZE} bytes`,
      );
    }

    const shiftLength = ivLength - BLOCK_SIZE;
    for (let i = 0; i < shiftLength; i++) {
      this.iv[i] = this.iv[i + BLOCK_SIZE];
    }
    for (let i = 0; i < BLOCK_SIZE; i++) {
      this.iv[shiftLength + i] = block[i];
    }
  }

  private validateIv(): void {
    if (this.iv.length < BLOCK_SIZE) {
      throw new Error(
        `Initialization vector not set or length less than ${BLOCK_SIZE} bytes`,
      );
    }
  }
}

```

`kuznechik/src/algcfb.ts`:

```ts
import type { Block128 } from "./types";
import { KeyStore } from "./keystore";
import {
  encryptBlock,
  sumMod2,
  additionBlockS2,
  additionRevBlock2,
} from "./transforms";

const BLOCK_SIZE = 16;
const DEFAULT_S = 16;

export class AlgCfb {
  private keyStore: KeyStore;
  private iv: Uint8Array;
  private s: number;

  constructor(keyStore: KeyStore) {
    this.keyStore = keyStore;
    this.iv = new Uint8Array(0);
    this.s = DEFAULT_S;
  }

  public setIv(iv: Uint8Array): void {
    if (iv.length < BLOCK_SIZE) {
      throw new Error(
        `Initialization vector length must be at least ${BLOCK_SIZE} bytes`,
      );
    }
    this.iv = iv.slice();
  }

  public setS(s: number): void {
    if (s <= 0 || s > BLOCK_SIZE) {
      throw new Error(`Parameter s must be between 1 and ${BLOCK_SIZE}`);
    }
    this.s = s;
  }

  public encrypt(data: Uint8Array): Uint8Array {
    this.validateIv();
    const paddedData = additionBlockS2(data, this.s);
    const blockCount = paddedData.length / this.s;

    for (let i = 0; i < blockCount; i++) {
      const block = paddedData.subarray(i * this.s, (i + 1) * this.s);
      const encryptedIv = this.getEncryptedIv();
      sumMod2(block, encryptedIv.subarray(0, this.s));
      this.updateIv(block);
    }

    return paddedData;
  }

  public decrypt(data: Uint8Array): Uint8Array {
    this.validateIv();
    const blockCount = data.length / this.s;
    const decryptedData = data.slice();

    for (let i = 0; i < blockCount; i++) {
      const block = decryptedData.subarray(i * this.s, (i + 1) * this.s);
      const encryptedIv = this.getEncryptedIv();
      this.updateIv(block);
      sumMod2(block, encryptedIv.subarray(0, this.s));
    }

    return additionRevBlock2(decryptedData);
  }

  private getEncryptedIv(): Block128 {
    const ivBlock = this.iv.subarray(0, BLOCK_SIZE);
    const encryptedIv = ivBlock.slice();
    encryptBlock(encryptedIv, this.keyStore.keys);
    return encryptedIv;
  }

  private updateIv(data: Uint8Array): void {
    const ivLength = this.iv.length;
    if (ivLength < BLOCK_SIZE) {
      throw new Error(
        `Initialization vector length must be at least ${BLOCK_SIZE} bytes`,
      );
    }
    if (data.length < this.s) {
      throw new Error(`Data length must be at least s bytes: ${this.s}`);
    }

    const shiftLength = ivLength - this.s;
    for (let i = 0; i < shiftLength; i++) {
      this.iv[i] = this.iv[i + this.s];
    }
    for (let i = 0; i < this.s; i++) {
      this.iv[shiftLength + i] = data[i];
    }
  }

  private validateIv(): void {
    if (this.iv.length < BLOCK_SIZE) {
      throw new Error(
        `Initialization vector not set or length less than ${BLOCK_SIZE} bytes`,
      );
    }
  }
}

```

`kuznechik/src/algctr.ts`:

```ts
import type { Block128 } from "./types";
import { KeyStore } from "./keystore";
import { encryptBlock, sumMod2 } from "./transforms";

const BLOCK_SIZE = 16;

export class AlgCtr {
  private kuz: KeyStore;
  private gamma: Uint8Array;

  constructor(kuz: KeyStore) {
    this.kuz = kuz;
    this.gamma = new Uint8Array(0);
  }

  public setGamma(gamma: Uint8Array): void {
    this.gamma = gamma.slice();
  }

  public encrypt(data: Uint8Array): Uint8Array {
    const encryptedData = data.slice();
    const blockCount = Math.floor(data.length / BLOCK_SIZE);

    for (let i = 0; i < blockCount; i++) {
      const block = this.getEncryptedCounter();
      sumMod2(
        encryptedData.subarray(i * BLOCK_SIZE, (i + 1) * BLOCK_SIZE),
        block,
      );
      this.incrementCounter();
    }

    const remainder = data.length % BLOCK_SIZE;
    if (remainder > 0) {
      const block = this.getEncryptedCounter();
      sumMod2(
        encryptedData.subarray(blockCount * BLOCK_SIZE),
        block.subarray(0, remainder),
      );
      this.incrementCounter();
    }

    return encryptedData;
  }

  public decrypt(data: Uint8Array): Uint8Array {
    return this.encrypt(data); // CTR mode is symmetric
  }

  private getEncryptedCounter(): Block128 {
    if (this.gamma.length < BLOCK_SIZE) {
      throw new Error(`Gamma must be at least ${BLOCK_SIZE} bytes`);
    }
    const counterBlock = this.gamma.subarray(0, BLOCK_SIZE).slice() as Block128;
    encryptBlock(counterBlock, this.kuz.keys);
    return counterBlock;
  }

  private incrementCounter(): void {
    for (let i = this.gamma.length - 1; i >= 0; i--) {
      this.gamma[i] = (this.gamma[i] + 1) & 0xff;
      if (this.gamma[i] !== 0) {
        break;
      }
    }
  }
}

```

`kuznechik/src/algecb.ts`:

```ts
import type { Block128 } from "./types";
import { KeyStore } from "./keystore";
import {
  encryptBlock,
  decryptBlock,
  additionBlock128_2,
  additionRevBlock2,
} from "./transforms";

export class AlgEcb {
  private kuz: KeyStore;

  constructor(kuz: KeyStore) {
    this.kuz = kuz;
  }

  public encrypt(data: Uint8Array): Uint8Array {
    let paddedData = additionBlock128_2(data);
    const blockSize = 16;
    const countBlocks = paddedData.length / blockSize;

    for (let i = 0; i < countBlocks; i++) {
      const block = paddedData.subarray(
        i * blockSize,
        (i + 1) * blockSize,
      ) as Block128;
      encryptBlock(block, this.kuz.keys);
    }
    return paddedData;
  }

  public decrypt(data: Uint8Array): Uint8Array {
    const blockSize = 16;
    const countBlocks = data.length / blockSize;
    let decryptedData = data.slice();

    for (let i = 0; i < countBlocks; i++) {
      const block = decryptedData.subarray(
        i * blockSize,
        (i + 1) * blockSize,
      ) as Block128;
      decryptBlock(block, this.kuz.keys);
    }

    return additionRevBlock2(decryptedData);
  }
}

```

`kuznechik/src/algmac.ts`:

```ts
import type { Block128 } from "./types";
import { KeyStore } from "./keystore";
import { encryptBlock, sumMod2 } from "./transforms";

const BLOCK_SIZE = 16;

export class AlgMac {
  private kuz: KeyStore;
  private s: number;
  private k1: Block128;
  private k2: Block128;

  constructor(kuz: KeyStore) {
    this.kuz = kuz;
    this.s = 8;
    this.k1 = new Uint8Array(BLOCK_SIZE);
    this.k2 = new Uint8Array(BLOCK_SIZE);
    this.makeK();
  }

  public encrypt(data: Uint8Array): Uint8Array {
    let mutableData = data.slice();
    const isAdded = additionBlock128_3(mutableData, BLOCK_SIZE);
    const countBlocks = mutableData.length / BLOCK_SIZE;

    let result = mutableData.subarray(0, BLOCK_SIZE).slice() as Block128;
    encryptBlock(result, this.kuz.keys);

    for (let i = 1; i < countBlocks - 1; i++) {
      const block = mutableData.subarray(i * BLOCK_SIZE, (i + 1) * BLOCK_SIZE);
      sumMod2(result, block);
      encryptBlock(result, this.kuz.keys);
    }

    const key = isAdded ? this.k2 : this.k1;
    const lastBlock = mutableData.subarray((countBlocks - 1) * BLOCK_SIZE);
    sumMod2(result, lastBlock);
    sumMod2(result, key);
    encryptBlock(result, this.kuz.keys);

    return result.subarray(0, this.s);
  }

  public decrypt(_data: Uint8Array): Uint8Array {
    throw new Error("AlgMac has no decrypt function");
  }

  private makeK(): void {
    this.k1 = new Uint8Array(BLOCK_SIZE);
    encryptBlock(this.k1, this.kuz.keys);
    mkK(this.k1);

    this.k2 = this.k1.slice();
    mkK(this.k2);
  }
}

function mkK(k: Block128): void {
  if (shiftLeft(k) === 1) {
    k[BLOCK_SIZE - 1] ^= 0x87;
  }
}

function shiftLeft(m: Uint8Array): number {
  const len = m.length;
  let h = 0;
  for (let i = len - 1; i >= 0; i--) {
    const temp = (m[i] >> 7) & 1;
    m[i] = (m[i] << 1) | h;
    h = temp;
  }
  return h;
}

function additionBlock128_3(data: Uint8Array, s: number): boolean {
  const r = data.length % s;
  if (r > 0) {
    const exData = new Uint8Array(s - r);
    exData[0] = 0x80;
    for (let i = 1; i < s - r; i++) {
      exData[i] = 0x00;
    }
    const newData = new Uint8Array(data.length + (s - r));
    newData.set(data);
    newData.set(exData, data.length);
    data = newData;
    return true;
  }
  return false;
}

```

`kuznechik/src/algofb.ts`:

```ts
import type { Block128 } from "./types";
import { KeyStore } from "./keystore";
import { encryptBlock, sumMod2 } from "./transforms";

const BLOCK_SIZE = 16;
const MIN_GAMMA_SIZE = 32;

export class AlgOfb {
  private kuz: KeyStore;
  private gamma: Uint8Array;

  constructor(kuz: KeyStore) {
    this.kuz = kuz;
    this.gamma = new Uint8Array(0);
  }

  public setGamma(gamma: Uint8Array): void {
    if (gamma.length < MIN_GAMMA_SIZE) {
      throw new Error(`Gamma must be at least ${MIN_GAMMA_SIZE} bytes`);
    }
    this.gamma = gamma.slice();
  }

  public encrypt(data: Uint8Array): Uint8Array {
    const encryptedData = data.slice();
    const blockCount = Math.floor(data.length / BLOCK_SIZE);

    for (let i = 0; i < blockCount; i++) {
      const block = this.getEncryptedGamma();
      sumMod2(
        encryptedData.subarray(i * BLOCK_SIZE, (i + 1) * BLOCK_SIZE),
        block,
      );
      this.updateGamma();
    }

    const remainder = data.length % BLOCK_SIZE;
    if (remainder > 0) {
      const block = this.getEncryptedGamma();
      sumMod2(
        encryptedData.subarray(blockCount * BLOCK_SIZE),
        block.subarray(0, remainder),
      );
      this.updateGamma();
    }

    return encryptedData;
  }

  public decrypt(data: Uint8Array): Uint8Array {
    return this.encrypt(data); // OFB mode is symmetric
  }

  private getEncryptedGamma(): Block128 {
    if (this.gamma.length < BLOCK_SIZE) {
      throw new Error(`Gamma must be at least ${BLOCK_SIZE} bytes`);
    }
    const gammaBlock = this.gamma.subarray(0, BLOCK_SIZE); // Убрали .slice()
    encryptBlock(gammaBlock, this.kuz.keys);
    return gammaBlock;
  }

  private updateGamma(): void {
    const len = this.gamma.length;
    if (len < MIN_GAMMA_SIZE) {
      throw new Error(`Gamma length must be at least ${MIN_GAMMA_SIZE} bytes`);
    }

    const temp = this.gamma.subarray(0, BLOCK_SIZE).slice();
    for (let i = BLOCK_SIZE; i < len; i++) {
      const swap = this.gamma[i];
      this.gamma[i] = this.gamma[i - BLOCK_SIZE];
      this.gamma[i - BLOCK_SIZE] = swap;
    }
    this.gamma.set(temp, len - BLOCK_SIZE);
  }
}

```

`kuznechik/src/keystore.ts`:

```ts
import type { Block128, Block256 } from "./types";
import { tfmC, tfmF } from "./transforms";

type HashFunction = (passwordBytes: Uint8Array) => Promise<Block256>;

const MASTER_KEY_SIZE = 32;
const KEY_SIZE = 16;
const NUM_KEYS = 10;
const OUTER_LOOP_ITERATIONS = 4;
const INNER_LOOP_ITERATIONS = 8;

export class KeyStore {
  public keys: Block128[];
  #masterKey: Block256;
  #hashFunction?: HashFunction;

  constructor() {
    this.#masterKey = new Uint8Array(MASTER_KEY_SIZE);
    this.keys = Array.from(
      { length: NUM_KEYS },
      () => new Uint8Array(KEY_SIZE),
    );
  }

  public setHashFunction(hashFunction: HashFunction): void {
    this.#hashFunction = hashFunction;
  }

  public async setPassword(password: Uint8Array): Promise<void> {
    if (this.#hashFunction) {
      this.#masterKey = await this.#hashFunction(password);
    }
    this.expandKey();
  }

  public setMasterKey(masterKey: Block256): void {
    if (masterKey.length !== MASTER_KEY_SIZE)
      throw new Error("Invalid master key length");
    this.#masterKey = masterKey.slice();
    this.expandKey();
  }

  private expandKey(): void {
    const c = new Uint8Array(KEY_SIZE);
    let constC = this.#masterKey.slice();

    this.keys[0].set(this.#masterKey.subarray(0, KEY_SIZE));
    this.keys[1].set(this.#masterKey.subarray(KEY_SIZE, MASTER_KEY_SIZE));

    let k = 2;
    for (let j = 0; j < OUTER_LOOP_ITERATIONS; j++) {
      for (let i = 1; i <= INNER_LOOP_ITERATIONS; i++) {
        tfmC(c, j * INNER_LOOP_ITERATIONS + i);
        tfmF(constC, c);
      }
      this.keys[k].set(constC.subarray(0, KEY_SIZE));
      k++;
      this.keys[k].set(constC.subarray(KEY_SIZE, MASTER_KEY_SIZE));
      k++;
    }
  }
}

```

`kuznechik/src/tables.ts`:

```ts
export const K_PI: Uint8Array = new Uint8Array([
  252, 238, 221, 17, 207, 110, 49, 22, 251, 196, 250, 218, 35, 197, 4, 77, 233,
  119, 240, 219, 147, 46, 153, 186, 23, 54, 241, 187, 20, 205, 95, 193, 249, 24,
  101, 90, 226, 92, 239, 33, 129, 28, 60, 66, 139, 1, 142, 79, 5, 132, 2, 174,
  227, 106, 143, 160, 6, 11, 237, 152, 127, 212, 211, 31, 235, 52, 44, 81, 234,
  200, 72, 171, 242, 42, 104, 162, 253, 58, 206, 204, 181, 112, 14, 86, 8, 12,
  118, 18, 191, 114, 19, 71, 156, 183, 93, 135, 21, 161, 150, 41, 16, 123, 154,
  199, 243, 145, 120, 111, 157, 158, 178, 177, 50, 117, 25, 61, 255, 53, 138,
  126, 109, 84, 198, 128, 195, 189, 13, 87, 223, 245, 36, 169, 62, 168, 67, 201,
  215, 121, 214, 246, 124, 34, 185, 3, 224, 15, 236, 222, 122, 148, 176, 188,
  220, 232, 40, 80, 78, 51, 10, 74, 167, 151, 96, 115, 30, 0, 98, 68, 26, 184,
  56, 130, 100, 159, 38, 65, 173, 69, 70, 146, 39, 94, 85, 47, 140, 163, 165,
  125, 105, 213, 149, 59, 7, 88, 179, 64, 134, 172, 29, 247, 48, 55, 107, 228,
  136, 217, 231, 137, 225, 27, 131, 73, 76, 63, 248, 254, 141, 83, 170, 144,
  202, 216, 133, 97, 32, 113, 103, 164, 45, 43, 9, 91, 203, 155, 37, 208, 190,
  229, 108, 82, 89, 166, 116, 210, 230, 244, 180, 192, 209, 102, 175, 194, 57,
  75, 99, 182,
]);

export const K_PI_REV: Uint8Array = new Uint8Array([
  0xa5, 0x2d, 0x32, 0x8f, 0x0e, 0x30, 0x38, 0xc0, 0x54, 0xe6, 0x9e, 0x39, 0x55,
  0x7e, 0x52, 0x91, 0x64, 0x03, 0x57, 0x5a, 0x1c, 0x60, 0x07, 0x18, 0x21, 0x72,
  0xa8, 0xd1, 0x29, 0xc6, 0xa4, 0x3f, 0xe0, 0x27, 0x8d, 0x0c, 0x82, 0xea, 0xae,
  0xb4, 0x9a, 0x63, 0x49, 0xe5, 0x42, 0xe4, 0x15, 0xb7, 0xc8, 0x06, 0x70, 0x9d,
  0x41, 0x75, 0x19, 0xc9, 0xaa, 0xfc, 0x4d, 0xbf, 0x2a, 0x73, 0x84, 0xd5, 0xc3,
  0xaf, 0x2b, 0x86, 0xa7, 0xb1, 0xb2, 0x5b, 0x46, 0xd3, 0x9f, 0xfd, 0xd4, 0x0f,
  0x9c, 0x2f, 0x9b, 0x43, 0xef, 0xd9, 0x79, 0xb6, 0x53, 0x7f, 0xc1, 0xf0, 0x23,
  0xe7, 0x25, 0x5e, 0xb5, 0x1e, 0xa2, 0xdf, 0xa6, 0xfe, 0xac, 0x22, 0xf9, 0xe2,
  0x4a, 0xbc, 0x35, 0xca, 0xee, 0x78, 0x05, 0x6b, 0x51, 0xe1, 0x59, 0xa3, 0xf2,
  0x71, 0x56, 0x11, 0x6a, 0x89, 0x94, 0x65, 0x8c, 0xbb, 0x77, 0x3c, 0x7b, 0x28,
  0xab, 0xd2, 0x31, 0xde, 0xc4, 0x5f, 0xcc, 0xcf, 0x76, 0x2c, 0xb8, 0xd8, 0x2e,
  0x36, 0xdb, 0x69, 0xb3, 0x14, 0x95, 0xbe, 0x62, 0xa1, 0x3b, 0x16, 0x66, 0xe9,
  0x5c, 0x6c, 0x6d, 0xad, 0x37, 0x61, 0x4b, 0xb9, 0xe3, 0xba, 0xf1, 0xa0, 0x85,
  0x83, 0xda, 0x47, 0xc5, 0xb0, 0x33, 0xfa, 0x96, 0x6f, 0x6e, 0xc2, 0xf6, 0x50,
  0xff, 0x5d, 0xa9, 0x8e, 0x17, 0x1b, 0x97, 0x7d, 0xec, 0x58, 0xf7, 0x1f, 0xfb,
  0x7c, 0x09, 0x0d, 0x7a, 0x67, 0x45, 0x87, 0xdc, 0xe8, 0x4f, 0x1d, 0x4e, 0x04,
  0xeb, 0xf8, 0xf3, 0x3e, 0x3d, 0xbd, 0x8a, 0x88, 0xdd, 0xcd, 0x0b, 0x13, 0x98,
  0x02, 0x93, 0x80, 0x90, 0xd0, 0x24, 0x34, 0xcb, 0xed, 0xf4, 0xce, 0x99, 0x10,
  0x44, 0x40, 0x92, 0x3a, 0x01, 0x26, 0x12, 0x1a, 0x48, 0x68, 0xf5, 0x81, 0x8b,
  0xc7, 0xd6, 0x20, 0x0a, 0x08, 0x00, 0x4c, 0xd7, 0x74,
]);

export const MULT_TABLE: Uint8Array[] = [
  new Uint8Array([
    0x00, 0x10, 0x20, 0x30, 0x40, 0x50, 0x60, 0x70, 0x80, 0x90, 0xa0, 0xb0,
    0xc0, 0xd0, 0xe0, 0xf0, 0xc3, 0xd3, 0xe3, 0xf3, 0x83, 0x93, 0xa3, 0xb3,
    0x43, 0x53, 0x63, 0x73, 0x03, 0x13, 0x23, 0x33, 0x45, 0x55, 0x65, 0x75,
    0x05, 0x15, 0x25, 0x35, 0xc5, 0xd5, 0xe5, 0xf5, 0x85, 0x95, 0xa5, 0xb5,
    0x86, 0x96, 0xa6, 0xb6, 0xc6, 0xd6, 0xe6, 0xf6, 0x06, 0x16, 0x26, 0x36,
    0x46, 0x56, 0x66, 0x76, 0x8a, 0x9a, 0xaa, 0xba, 0xca, 0xda, 0xea, 0xfa,
    0x0a, 0x1a, 0x2a, 0x3a, 0x4a, 0x5a, 0x6a, 0x7a, 0x49, 0x59, 0x69, 0x79,
    0x09, 0x19, 0x29, 0x39, 0xc9, 0xd9, 0xe9, 0xf9, 0x89, 0x99, 0xa9, 0xb9,
    0xcf, 0xdf, 0xef, 0xff, 0x8f, 0x9f, 0xaf, 0xbf, 0x4f, 0x5f, 0x6f, 0x7f,
    0x0f, 0x1f, 0x2f, 0x3f, 0x0c, 0x1c, 0x2c, 0x3c, 0x4c, 0x5c, 0x6c, 0x7c,
    0x8c, 0x9c, 0xac, 0xbc, 0xcc, 0xdc, 0xec, 0xfc, 0xd7, 0xc7, 0xf7, 0xe7,
    0x97, 0x87, 0xb7, 0xa7, 0x57, 0x47, 0x77, 0x67, 0x17, 0x07, 0x37, 0x27,
    0x14, 0x04, 0x34, 0x24, 0x54, 0x44, 0x74, 0x64, 0x94, 0x84, 0xb4, 0xa4,
    0xd4, 0xc4, 0xf4, 0xe4, 0x92, 0x82, 0xb2, 0xa2, 0xd2, 0xc2, 0xf2, 0xe2,
    0x12, 0x02, 0x32, 0x22, 0x52, 0x42, 0x72, 0x62, 0x51, 0x41, 0x71, 0x61,
    0x11, 0x01, 0x31, 0x21, 0xd1, 0xc1, 0xf1, 0xe1, 0x91, 0x81, 0xb1, 0xa1,
    0x5d, 0x4d, 0x7d, 0x6d, 0x1d, 0x0d, 0x3d, 0x2d, 0xdd, 0xcd, 0xfd, 0xed,
    0x9d, 0x8d, 0xbd, 0xad, 0x9e, 0x8e, 0xbe, 0xae, 0xde, 0xce, 0xfe, 0xee,
    0x1e, 0x0e, 0x3e, 0x2e, 0x5e, 0x4e, 0x7e, 0x6e, 0x18, 0x08, 0x38, 0x28,
    0x58, 0x48, 0x78, 0x68, 0x98, 0x88, 0xb8, 0xa8, 0xd8, 0xc8, 0xf8, 0xe8,
    0xdb, 0xcb, 0xfb, 0xeb, 0x9b, 0x8b, 0xbb, 0xab, 0x5b, 0x4b, 0x7b, 0x6b,
    0x1b, 0x0b, 0x3b, 0x2b,
  ]),
  new Uint8Array([
    0x00, 0x20, 0x40, 0x60, 0x80, 0xa0, 0xc0, 0xe0, 0xc3, 0xe3, 0x83, 0xa3,
    0x43, 0x63, 0x03, 0x23, 0x45, 0x65, 0x05, 0x25, 0xc5, 0xe5, 0x85, 0xa5,
    0x86, 0xa6, 0xc6, 0xe6, 0x06, 0x26, 0x46, 0x66, 0x8a, 0xaa, 0xca, 0xea,
    0x0a, 0x2a, 0x4a, 0x6a, 0x49, 0x69, 0x09, 0x29, 0xc9, 0xe9, 0x89, 0xa9,
    0xcf, 0xef, 0x8f, 0xaf, 0x4f, 0x6f, 0x0f, 0x2f, 0x0c, 0x2c, 0x4c, 0x6c,
    0x8c, 0xac, 0xcc, 0xec, 0xd7, 0xf7, 0x97, 0xb7, 0x57, 0x77, 0x17, 0x37,
    0x14, 0x34, 0x54, 0x74, 0x94, 0xb4, 0xd4, 0xf4, 0x92, 0xb2, 0xd2, 0xf2,
    0x12, 0x32, 0x52, 0x72, 0x51, 0x71, 0x11, 0x31, 0xd1, 0xf1, 0x91, 0xb1,
    0x5d, 0x7d, 0x1d, 0x3d, 0xdd, 0xfd, 0x9d, 0xbd, 0x9e, 0xbe, 0xde, 0xfe,
    0x1e, 0x3e, 0x5e, 0x7e, 0x18, 0x38, 0x58, 0x78, 0x98, 0xb8, 0xd8, 0xf8,
    0xdb, 0xfb, 0x9b, 0xbb, 0x5b, 0x7b, 0x1b, 0x3b, 0x6d, 0x4d, 0x2d, 0x0d,
    0xed, 0xcd, 0xad, 0x8d, 0xae, 0x8e, 0xee, 0xce, 0x2e, 0x0e, 0x6e, 0x4e,
    0x28, 0x08, 0x68, 0x48, 0xa8, 0x88, 0xe8, 0xc8, 0xeb, 0xcb, 0xab, 0x8b,
    0x6b, 0x4b, 0x2b, 0x0b, 0xe7, 0xc7, 0xa7, 0x87, 0x67, 0x47, 0x27, 0x07,
    0x24, 0x04, 0x64, 0x44, 0xa4, 0x84, 0xe4, 0xc4, 0xa2, 0x82, 0xe2, 0xc2,
    0x22, 0x02, 0x62, 0x42, 0x61, 0x41, 0x21, 0x01, 0xe1, 0xc1, 0xa1, 0x81,
    0xba, 0x9a, 0xfa, 0xda, 0x3a, 0x1a, 0x7a, 0x5a, 0x79, 0x59, 0x39, 0x19,
    0xf9, 0xd9, 0xb9, 0x99, 0xff, 0xdf, 0xbf, 0x9f, 0x7f, 0x5f, 0x3f, 0x1f,
    0x3c, 0x1c, 0x7c, 0x5c, 0xbc, 0x9c, 0xfc, 0xdc, 0x30, 0x10, 0x70, 0x50,
    0xb0, 0x90, 0xf0, 0xd0, 0xf3, 0xd3, 0xb3, 0x93, 0x73, 0x53, 0x33, 0x13,
    0x75, 0x55, 0x35, 0x15, 0xf5, 0xd5, 0xb5, 0x95, 0xb6, 0x96, 0xf6, 0xd6,
    0x36, 0x16, 0x76, 0x56,
  ]),
  new Uint8Array([
    0x00, 0x85, 0xc9, 0x4c, 0x51, 0xd4, 0x98, 0x1d, 0xa2, 0x27, 0x6b, 0xee,
    0xf3, 0x76, 0x3a, 0xbf, 0x87, 0x02, 0x4e, 0xcb, 0xd6, 0x53, 0x1f, 0x9a,
    0x25, 0xa0, 0xec, 0x69, 0x74, 0xf1, 0xbd, 0x38, 0xcd, 0x48, 0x04, 0x81,
    0x9c, 0x19, 0x55, 0xd0, 0x6f, 0xea, 0xa6, 0x23, 0x3e, 0xbb, 0xf7, 0x72,
    0x4a, 0xcf, 0x83, 0x06, 0x1b, 0x9e, 0xd2, 0x57, 0xe8, 0x6d, 0x21, 0xa4,
    0xb9, 0x3c, 0x70, 0xf5, 0x59, 0xdc, 0x90, 0x15, 0x08, 0x8d, 0xc1, 0x44,
    0xfb, 0x7e, 0x32, 0xb7, 0xaa, 0x2f, 0x63, 0xe6, 0xde, 0x5b, 0x17, 0x92,
    0x8f, 0x0a, 0x46, 0xc3, 0x7c, 0xf9, 0xb5, 0x30, 0x2d, 0xa8, 0xe4, 0x61,
    0x94, 0x11, 0x5d, 0xd8, 0xc5, 0x40, 0x0c, 0x89, 0x36, 0xb3, 0xff, 0x7a,
    0x67, 0xe2, 0xae, 0x2b, 0x13, 0x96, 0xda, 0x5f, 0x42, 0xc7, 0x8b, 0x0e,
    0xb1, 0x34, 0x78, 0xfd, 0xe0, 0x65, 0x29, 0xac, 0xb2, 0x37, 0x7b, 0xfe,
    0xe3, 0x66, 0x2a, 0xaf, 0x10, 0x95, 0xd9, 0x5c, 0x41, 0xc4, 0x88, 0x0d,
    0x35, 0xb0, 0xfc, 0x79, 0x64, 0xe1, 0xad, 0x28, 0x97, 0x12, 0x5e, 0xdb,
    0xc6, 0x43, 0x0f, 0x8a, 0x7f, 0xfa, 0xb6, 0x33, 0x2e, 0xab, 0xe7, 0x62,
    0xdd, 0x58, 0x14, 0x91, 0x8c, 0x09, 0x45, 0xc0, 0xf8, 0x7d, 0x31, 0xb4,
    0xa9, 0x2c, 0x60, 0xe5, 0x5a, 0xdf, 0x93, 0x16, 0x0b, 0x8e, 0xc2, 0x47,
    0xeb, 0x6e, 0x22, 0xa7, 0xba, 0x3f, 0x73, 0xf6, 0x49, 0xcc, 0x80, 0x05,
    0x18, 0x9d, 0xd1, 0x54, 0x6c, 0xe9, 0xa5, 0x20, 0x3d, 0xb8, 0xf4, 0x71,
    0xce, 0x4b, 0x07, 0x82, 0x9f, 0x1a, 0x56, 0xd3, 0x26, 0xa3, 0xef, 0x6a,
    0x77, 0xf2, 0xbe, 0x3b, 0x84, 0x01, 0x4d, 0xc8, 0xd5, 0x50, 0x1c, 0x99,
    0xa1, 0x24, 0x68, 0xed, 0xf0, 0x75, 0x39, 0xbc, 0x03, 0x86, 0xca, 0x4f,
    0x52, 0xd7, 0x9b, 0x1e,
  ]),
  new Uint8Array([
    0x00, 0x94, 0xeb, 0x7f, 0x15, 0x81, 0xfe, 0x6a, 0x2a, 0xbe, 0xc1, 0x55,
    0x3f, 0xab, 0xd4, 0x40, 0x54, 0xc0, 0xbf, 0x2b, 0x41, 0xd5, 0xaa, 0x3e,
    0x7e, 0xea, 0x95, 0x01, 0x6b, 0xff, 0x80, 0x14, 0xa8, 0x3c, 0x43, 0xd7,
    0xbd, 0x29, 0x56, 0xc2, 0x82, 0x16, 0x69, 0xfd, 0x97, 0x03, 0x7c, 0xe8,
    0xfc, 0x68, 0x17, 0x83, 0xe9, 0x7d, 0x02, 0x96, 0xd6, 0x42, 0x3d, 0xa9,
    0xc3, 0x57, 0x28, 0xbc, 0x93, 0x07, 0x78, 0xec, 0x86, 0x12, 0x6d, 0xf9,
    0xb9, 0x2d, 0x52, 0xc6, 0xac, 0x38, 0x47, 0xd3, 0xc7, 0x53, 0x2c, 0xb8,
    0xd2, 0x46, 0x39, 0xad, 0xed, 0x79, 0x06, 0x92, 0xf8, 0x6c, 0x13, 0x87,
    0x3b, 0xaf, 0xd0, 0x44, 0x2e, 0xba, 0xc5, 0x51, 0x11, 0x85, 0xfa, 0x6e,
    0x04, 0x90, 0xef, 0x7b, 0x6f, 0xfb, 0x84, 0x10, 0x7a, 0xee, 0x91, 0x05,
    0x45, 0xd1, 0xae, 0x3a, 0x50, 0xc4, 0xbb, 0x2f, 0xe5, 0x71, 0x0e, 0x9a,
    0xf0, 0x64, 0x1b, 0x8f, 0xcf, 0x5b, 0x24, 0xb0, 0xda, 0x4e, 0x31, 0xa5,
    0xb1, 0x25, 0x5a, 0xce, 0xa4, 0x30, 0x4f, 0xdb, 0x9b, 0x0f, 0x70, 0xe4,
    0x8e, 0x1a, 0x65, 0xf1, 0x4d, 0xd9, 0xa6, 0x32, 0x58, 0xcc, 0xb3, 0x27,
    0x67, 0xf3, 0x8c, 0x18, 0x72, 0xe6, 0x99, 0x0d, 0x19, 0x8d, 0xf2, 0x66,
    0x0c, 0x98, 0xe7, 0x73, 0x33, 0xa7, 0xd8, 0x4c, 0x26, 0xb2, 0xcd, 0x59,
    0x76, 0xe2, 0x9d, 0x09, 0x63, 0xf7, 0x88, 0x1c, 0x5c, 0xc8, 0xb7, 0x23,
    0x49, 0xdd, 0xa2, 0x36, 0x22, 0xb6, 0xc9, 0x5d, 0x37, 0xa3, 0xdc, 0x48,
    0x08, 0x9c, 0xe3, 0x77, 0x1d, 0x89, 0xf6, 0x62, 0xde, 0x4a, 0x35, 0xa1,
    0xcb, 0x5f, 0x20, 0xb4, 0xf4, 0x60, 0x1f, 0x8b, 0xe1, 0x75, 0x0a, 0x9e,
    0x8a, 0x1e, 0x61, 0xf5, 0x9f, 0x0b, 0x74, 0xe0, 0xa0, 0x34, 0x4b, 0xdf,
    0xb5, 0x21, 0x5e, 0xca,
  ]),
  new Uint8Array([
    0x00, 0xc0, 0x43, 0x83, 0x86, 0x46, 0xc5, 0x05, 0xcf, 0x0f, 0x8c, 0x4c,
    0x49, 0x89, 0x0a, 0xca, 0x5d, 0x9d, 0x1e, 0xde, 0xdb, 0x1b, 0x98, 0x58,
    0x92, 0x52, 0xd1, 0x11, 0x14, 0xd4, 0x57, 0x97, 0xba, 0x7a, 0xf9, 0x39,
    0x3c, 0xfc, 0x7f, 0xbf, 0x75, 0xb5, 0x36, 0xf6, 0xf3, 0x33, 0xb0, 0x70,
    0xe7, 0x27, 0xa4, 0x64, 0x61, 0xa1, 0x22, 0xe2, 0x28, 0xe8, 0x6b, 0xab,
    0xae, 0x6e, 0xed, 0x2d, 0xb7, 0x77, 0xf4, 0x34, 0x31, 0xf1, 0x72, 0xb2,
    0x78, 0xb8, 0x3b, 0xfb, 0xfe, 0x3e, 0xbd, 0x7d, 0xea, 0x2a, 0xa9, 0x69,
    0x6c, 0xac, 0x2f, 0xef, 0x25, 0xe5, 0x66, 0xa6, 0xa3, 0x63, 0xe0, 0x20,
    0x0d, 0xcd, 0x4e, 0x8e, 0x8b, 0x4b, 0xc8, 0x08, 0xc2, 0x02, 0x81, 0x41,
    0x44, 0x84, 0x07, 0xc7, 0x50, 0x90, 0x13, 0xd3, 0xd6, 0x16, 0x95, 0x55,
    0x9f, 0x5f, 0xdc, 0x1c, 0x19, 0xd9, 0x5a, 0x9a, 0xad, 0x6d, 0xee, 0x2e,
    0x2b, 0xeb, 0x68, 0xa8, 0x62, 0xa2, 0x21, 0xe1, 0xe4, 0x24, 0xa7, 0x67,
    0xf0, 0x30, 0xb3, 0x73, 0x76, 0xb6, 0x35, 0xf5, 0x3f, 0xff, 0x7c, 0xbc,
    0xb9, 0x79, 0xfa, 0x3a, 0x17, 0xd7, 0x54, 0x94, 0x91, 0x51, 0xd2, 0x12,
    0xd8, 0x18, 0x9b, 0x5b, 0x5e, 0x9e, 0x1d, 0xdd, 0x4a, 0x8a, 0x09, 0xc9,
    0xcc, 0x0c, 0x8f, 0x4f, 0x85, 0x45, 0xc6, 0x06, 0x03, 0xc3, 0x40, 0x80,
    0x1a, 0xda, 0x59, 0x99, 0x9c, 0x5c, 0xdf, 0x1f, 0xd5, 0x15, 0x96, 0x56,
    0x53, 0x93, 0x10, 0xd0, 0x47, 0x87, 0x04, 0xc4, 0xc1, 0x01, 0x82, 0x42,
    0x88, 0x48, 0xcb, 0x0b, 0x0e, 0xce, 0x4d, 0x8d, 0xa0, 0x60, 0xe3, 0x23,
    0x26, 0xe6, 0x65, 0xa5, 0x6f, 0xaf, 0x2c, 0xec, 0xe9, 0x29, 0xaa, 0x6a,
    0xfd, 0x3d, 0xbe, 0x7e, 0x7b, 0xbb, 0x38, 0xf8, 0x32, 0xf2, 0x71, 0xb1,
    0xb4, 0x74, 0xf7, 0x37,
  ]),
  new Uint8Array([
    0x00, 0xc2, 0x47, 0x85, 0x8e, 0x4c, 0xc9, 0x0b, 0xdf, 0x1d, 0x98, 0x5a,
    0x51, 0x93, 0x16, 0xd4, 0x7d, 0xbf, 0x3a, 0xf8, 0xf3, 0x31, 0xb4, 0x76,
    0xa2, 0x60, 0xe5, 0x27, 0x2c, 0xee, 0x6b, 0xa9, 0xfa, 0x38, 0xbd, 0x7f,
    0x74, 0xb6, 0x33, 0xf1, 0x25, 0xe7, 0x62, 0xa0, 0xab, 0x69, 0xec, 0x2e,
    0x87, 0x45, 0xc0, 0x02, 0x09, 0xcb, 0x4e, 0x8c, 0x58, 0x9a, 0x1f, 0xdd,
    0xd6, 0x14, 0x91, 0x53, 0x37, 0xf5, 0x70, 0xb2, 0xb9, 0x7b, 0xfe, 0x3c,
    0xe8, 0x2a, 0xaf, 0x6d, 0x66, 0xa4, 0x21, 0xe3, 0x4a, 0x88, 0x0d, 0xcf,
    0xc4, 0x06, 0x83, 0x41, 0x95, 0x57, 0xd2, 0x10, 0x1b, 0xd9, 0x5c, 0x9e,
    0xcd, 0x0f, 0x8a, 0x48, 0x43, 0x81, 0x04, 0xc6, 0x12, 0xd0, 0x55, 0x97,
    0x9c, 0x5e, 0xdb, 0x19, 0xb0, 0x72, 0xf7, 0x35, 0x3e, 0xfc, 0x79, 0xbb,
    0x6f, 0xad, 0x28, 0xea, 0xe1, 0x23, 0xa6, 0x64, 0x6e, 0xac, 0x29, 0xeb,
    0xe0, 0x22, 0xa7, 0x65, 0xb1, 0x73, 0xf6, 0x34, 0x3f, 0xfd, 0x78, 0xba,
    0x13, 0xd1, 0x54, 0x96, 0x9d, 0x5f, 0xda, 0x18, 0xcc, 0x0e, 0x8b, 0x49,
    0x42, 0x80, 0x05, 0xc7, 0x94, 0x56, 0xd3, 0x11, 0x1a, 0xd8, 0x5d, 0x9f,
    0x4b, 0x89, 0x0c, 0xce, 0xc5, 0x07, 0x82, 0x40, 0xe9, 0x2b, 0xae, 0x6c,
    0x67, 0xa5, 0x20, 0xe2, 0x36, 0xf4, 0x71, 0xb3, 0xb8, 0x7a, 0xff, 0x3d,
    0x59, 0x9b, 0x1e, 0xdc, 0xd7, 0x15, 0x90, 0x52, 0x86, 0x44, 0xc1, 0x03,
    0x08, 0xca, 0x4f, 0x8d, 0x24, 0xe6, 0x63, 0xa1, 0xaa, 0x68, 0xed, 0x2f,
    0xfb, 0x39, 0xbc, 0x7e, 0x75, 0xb7, 0x32, 0xf0, 0xa3, 0x61, 0xe4, 0x26,
    0x2d, 0xef, 0x6a, 0xa8, 0x7c, 0xbe, 0x3b, 0xf9, 0xf2, 0x30, 0xb5, 0x77,
    0xde, 0x1c, 0x99, 0x5b, 0x50, 0x92, 0x17, 0xd5, 0x01, 0xc3, 0x46, 0x84,
    0x8f, 0x4d, 0xc8, 0x0a,
  ]),
  new Uint8Array([
    0x00, 0xfb, 0x35, 0xce, 0x6a, 0x91, 0x5f, 0xa4, 0xd4, 0x2f, 0xe1, 0x1a,
    0xbe, 0x45, 0x8b, 0x70, 0x6b, 0x90, 0x5e, 0xa5, 0x01, 0xfa, 0x34, 0xcf,
    0xbf, 0x44, 0x8a, 0x71, 0xd5, 0x2e, 0xe0, 0x1b, 0xd6, 0x2d, 0xe3, 0x18,
    0xbc, 0x47, 0x89, 0x72, 0x02, 0xf9, 0x37, 0xcc, 0x68, 0x93, 0x5d, 0xa6,
    0xbd, 0x46, 0x88, 0x73, 0xd7, 0x2c, 0xe2, 0x19, 0x69, 0x92, 0x5c, 0xa7,
    0x03, 0xf8, 0x36, 0xcd, 0x6f, 0x94, 0x5a, 0xa1, 0x05, 0xfe, 0x30, 0xcb,
    0xbb, 0x40, 0x8e, 0x75, 0xd1, 0x2a, 0xe4, 0x1f, 0x04, 0xff, 0x31, 0xca,
    0x6e, 0x95, 0x5b, 0xa0, 0xd0, 0x2b, 0xe5, 0x1e, 0xba, 0x41, 0x8f, 0x74,
    0xb9, 0x42, 0x8c, 0x77, 0xd3, 0x28, 0xe6, 0x1d, 0x6d, 0x96, 0x58, 0xa3,
    0x07, 0xfc, 0x32, 0xc9, 0xd2, 0x29, 0xe7, 0x1c, 0xb8, 0x43, 0x8d, 0x76,
    0x06, 0xfd, 0x33, 0xc8, 0x6c, 0x97, 0x59, 0xa2, 0xde, 0x25, 0xeb, 0x10,
    0xb4, 0x4f, 0x81, 0x7a, 0x0a, 0xf1, 0x3f, 0xc4, 0x60, 0x9b, 0x55, 0xae,
    0xb5, 0x4e, 0x80, 0x7b, 0xdf, 0x24, 0xea, 0x11, 0x61, 0x9a, 0x54, 0xaf,
    0x0b, 0xf0, 0x3e, 0xc5, 0x08, 0xf3, 0x3d, 0xc6, 0x62, 0x99, 0x57, 0xac,
    0xdc, 0x27, 0xe9, 0x12, 0xb6, 0x4d, 0x83, 0x78, 0x63, 0x98, 0x56, 0xad,
    0x09, 0xf2, 0x3c, 0xc7, 0xb7, 0x4c, 0x82, 0x79, 0xdd, 0x26, 0xe8, 0x13,
    0xb1, 0x4a, 0x84, 0x7f, 0xdb, 0x20, 0xee, 0x15, 0x65, 0x9e, 0x50, 0xab,
    0x0f, 0xf4, 0x3a, 0xc1, 0xda, 0x21, 0xef, 0x14, 0xb0, 0x4b, 0x85, 0x7e,
    0x0e, 0xf5, 0x3b, 0xc0, 0x64, 0x9f, 0x51, 0xaa, 0x67, 0x9c, 0x52, 0xa9,
    0x0d, 0xf6, 0x38, 0xc3, 0xb3, 0x48, 0x86, 0x7d, 0xd9, 0x22, 0xec, 0x17,
    0x0c, 0xf7, 0x39, 0xc2, 0x66, 0x9d, 0x53, 0xa8, 0xd8, 0x23, 0xed, 0x16,
    0xb2, 0x49, 0x87, 0x7c,
  ]),
];

```

`kuznechik/src/transforms.ts`:

```ts
import type { Block128, Block256 } from "./types";
import { K_PI, K_PI_REV, MULT_TABLE } from "./tables";

const BLOCK_SIZE = 16;
const KEY_COUNT = 10;

export function encryptBlock(data: Block128, keys: Block128[]): void {
  if (data.length !== BLOCK_SIZE || keys.length !== KEY_COUNT)
    throw new Error("Invalid input length");
  for (let i = 0; i < KEY_COUNT - 1; i++) {
    tfmLsx(data, keys[i]);
  }
  tfmX(data, keys[KEY_COUNT - 1]);
}

export function decryptBlock(data: Block128, keys: Block128[]): void {
  if (data.length !== BLOCK_SIZE || keys.length !== KEY_COUNT)
    throw new Error("Invalid input length");
  for (let i = KEY_COUNT - 1; i > 0; i--) {
    tfmX(data, keys[i]);
    tfmRevL(data);
    tfmRevS(data);
  }
  tfmX(data, keys[0]);
}

export function tfmC(data: Block128, number: number): void {
  if (data.length !== BLOCK_SIZE) throw new Error("Invalid data length");
  data.fill(0);
  data[BLOCK_SIZE - 1] = number;
  tfmL(data);
}

export function tfmF(data: Block256, key: Block128): void {
  if (data.length !== BLOCK_SIZE * 2 || key.length !== BLOCK_SIZE)
    throw new Error("Invalid input length");
  const temp = data.subarray(0, BLOCK_SIZE).slice();
  tfmLsx(data.subarray(0, BLOCK_SIZE), key);
  tfmXBlock256(data);
  data.set(temp, BLOCK_SIZE);
}

export function tfmLsx(data: Block128, key: Block128): void {
  tfmX(data, key);
  tfmS(data);
  tfmL(data);
}

export function tfmX(data: Block128, key: Block128): void {
  for (let i = 0; i < BLOCK_SIZE; i++) {
    data[i] ^= key[i];
  }
}

export function tfmXBlock256(data: Block256): void {
  for (let i = 0; i < BLOCK_SIZE; i++) {
    data[i] ^= data[i + BLOCK_SIZE];
  }
}

export function tfmS(data: Block128): void {
  for (let i = 0; i < BLOCK_SIZE; i++) {
    data[i] = K_PI[data[i]];
  }
}

export function tfmL(data: Block128): void {
  for (let i = 0; i < BLOCK_SIZE; i++) {
    tfmR(data);
  }
}

export function tfmR(data: Block128): void {
  const temp = trfLinear(data);
  for (let i = BLOCK_SIZE - 1; i > 0; i--) {
    data[i] = data[i - 1];
  }
  data[0] = temp;
}

export function trfLinear(data: Block128): number {
  let res = 0;
  res ^= MULT_TABLE[3][data[0]];
  res ^= MULT_TABLE[1][data[1]];
  res ^= MULT_TABLE[2][data[2]];
  res ^= MULT_TABLE[0][data[3]];
  res ^= MULT_TABLE[5][data[4]];
  res ^= MULT_TABLE[4][data[5]];
  res ^= data[6];
  res ^= MULT_TABLE[6][data[7]];
  res ^= data[8];
  res ^= MULT_TABLE[4][data[9]];
  res ^= MULT_TABLE[5][data[10]];
  res ^= MULT_TABLE[0][data[11]];
  res ^= MULT_TABLE[2][data[12]];
  res ^= MULT_TABLE[1][data[13]];
  res ^= MULT_TABLE[3][data[14]];
  res ^= data[15];
  return res;
}

export function tfmRevS(data: Block128): void {
  for (let i = 0; i < BLOCK_SIZE; i++) {
    data[i] = K_PI_REV[data[i]];
  }
}

export function tfmRevR(data: Block128): void {
  const originalFirst = data[0];
  for (let i = 0; i < BLOCK_SIZE - 1; i++) {
    data[i] = data[i + 1];
  }
  data[BLOCK_SIZE - 1] = originalFirst;
  const linear = trfLinear(data);
  data[BLOCK_SIZE - 1] = linear;
}

export function tfmRevL(data: Block128): void {
  for (let i = 0; i < BLOCK_SIZE; i++) {
    tfmRevR(data);
  }
}

export function sumMod2(b1: Uint8Array, b2: Uint8Array): void {
  if (b1.length > b2.length) throw new Error("b1 length exceeds b2");
  for (let i = 0; i < b1.length; i++) {
    b1[i] ^= b2[i];
  }
}

export function additionBlock128_2(data: Uint8Array): Uint8Array {
  return additionBlockS2(data, BLOCK_SIZE);
}

export function additionBlockS2(data: Uint8Array, s: number): Uint8Array {
  const len = data.length;
  const r = len % s === 0 ? s : len % s;
  const newData = new Uint8Array(len + r);
  newData.set(data);
  newData[len] = 0x80;
  return newData;
}

export function additionRevBlock2(data: Uint8Array): Uint8Array {
  const pos = data.lastIndexOf(0x80);
  const newLen = pos === -1 ? data.length : pos;
  return data.subarray(0, newLen);
}

```

`kuznechik/src/types.ts`:

```ts
export type Block128 = Uint8Array;
export type Block256 = Uint8Array;

```